# main.py

import sys
import os
import json
from datetime import datetime, date

# Ajouter le r√©pertoire 'scripts' au PYTHONPATH pour importer les modules
sys.path.append(os.path.join(os.path.dirname(__file__), 'scripts'))

import get_top_clips
import download_clip
import process_video
import generate_metadata
import upload_youtube


# --- Chemins et configuration ---
DATA_DIR = os.path.join(os.path.dirname(__file__), 'data')
os.makedirs(DATA_DIR, exist_ok=True)

PUBLISHED_HISTORY_FILE = os.path.join(DATA_DIR, 'published_shorts_history.json')
# Fichiers temporaires pour le clip
RAW_CLIP_PATH = os.path.join(DATA_DIR, 'temp_raw_clip.mp4')
PROCESSED_CLIP_PATH = os.path.join(DATA_DIR, 'temp_processed_short.mp4')

# --- CONSTANTE DE CONFIGURATION CL√â ---
# Nombre de clips que le script essaiera de publier lors d'UNE SEULE EX√âCUTION du workflow.
# Si votre GitHub Action est configur√©e pour s'ex√©cuter 3 fois par jour, laissez cette valeur √† 1.
# Si votre GitHub Action s'ex√©cute 1 fois par jour et que vous voulez 3 clips, changez cette valeur √† 3.
NUMBER_OF_CLIPS_TO_ATTEMPT_TO_PUBLISH = 3
# ----------------------------------------

# --- Fonctions utilitaires pour l'historique ---
def load_published_history():
    """Charge l'historique des clips publi√©s."""
    if not os.path.exists(PUBLISHED_HISTORY_FILE):
        return {}
    try:
        with open(PUBLISHED_HISTORY_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except json.JSONDecodeError:
        print("‚ö†Ô∏è Fichier d'historique des publications corrompu. Cr√©ation d'un nouveau.")
        return {}
    except Exception as e:
        print(f"‚ùå Erreur inattendue lors du chargement de l'historique : {e}")
        return {}

def save_published_history(history_data):
    """Sauvegarde l'historique des clips publi√©s."""
    try:
        with open(PUBLISHED_HISTORY_FILE, 'w', encoding='utf-8') as f:
            json.dump(history_data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå Erreur inattendue lors de la sauvegarde de l'historique : {e}")


def get_today_published_ids(history_data):
    """Retourne les IDs des clips publi√©s aujourd'hui."""
    today_str = date.today().isoformat()
    # history_data est un dict { "YYYY-MM-DD": [ {clip_id: ..., youtube_id: ...}, ... ] }
    # Retourne seulement les 'twitch_clip_id' pour la date d'aujourd'hui
    return [item["twitch_clip_id"] for item in history_data.get(today_str, [])]

def add_to_history(history_data, clip_id, youtube_id):
    """Ajoute un clip √† l'historique pour la date d'aujourd'hui."""
    today_str = date.today().isoformat()
    if today_str not in history_data:
        history_data[today_str] = []
        
    # V√©rifier si l'ID Twitch est d√©j√† dans la liste d'aujourd'hui pour √©viter les doublons accidentels
    # (bien que la logique de s√©lection devrait d√©j√† filtrer cela)
    if not any(item["twitch_clip_id"] == clip_id for item in history_data[today_str]):
        history_data[today_str].append({
            "twitch_clip_id": clip_id, 
            "youtube_short_id": youtube_id, 
            "timestamp": datetime.now().isoformat()
        })
    
    # OPTIONNEL: Nettoyer l'historique des anciennes entr√©es (ex: plus de 7 jours)
    # C'est une bonne pratique pour √©viter que le fichier ne devienne trop gros.
    # D√©commentez le bloc ci-dessous si vous voulez cette fonctionnalit√©.
    # old_dates = []
    # for d in history_data:
    #     try:
    #         if (datetime.now().date() - datetime.fromisoformat(d).date()).days > 7:
    #             old_dates.append(d)
    #     except ValueError: # G√©rer les dates mal format√©es si n√©cessaire
    #         print(f"‚ö†Ô∏è Date mal format√©e dans l'historique : {d}. Ignor√©e.")
    # for d in old_dates:
    #     del history_data[d]
    # if old_dates:
    #     print(f"Historique nettoy√©. {len(old_dates)} anciennes entr√©es supprim√©es.")


def main():
    print("üöÄ D√©but du workflow de publication de Short YouTube...")

    # 1. Charger l'historique des clips publi√©s
    history = load_published_history()
    today_published_ids = get_today_published_ids(history)
    print(f"Clips d√©j√† publi√©s aujourd'hui (selon l'historique) : {len(today_published_ids)} IDs.")

    # Garder une trace des clips que nous avons ATTEMPT√â de publier DANS CETTE EX√âCUTION
    # pour √©viter de retenter le m√™me si la premi√®re tentative √©choue et la boucle continue.
    clips_attempted_in_this_run = []

    # 2. R√©cup√©rer le jeton d'acc√®s Twitch
    twitch_token = get_top_clips.get_twitch_access_token()
    if not twitch_token:
        print("‚ùå Impossible d'obtenir le jeton d'acc√®s Twitch. Fin du script.")
        return # Quitter la fonction main sans sys.exit(1) pour √©viter un √©chec "fatal" du workflow.

    # 3. R√©cup√©rer TOUS les clips √©ligibles et tri√©s
    # On passe les IDs d√©j√† publi√©s AUJOURD'HUI pour qu'ils soient filtr√©s d√®s la source.
    eligible_clips_list = get_top_clips.get_eligible_short_clips(
        access_token=twitch_token,
        num_clips_per_source=50, # Augmenter pour avoir plus de candidats
        days_ago=1, # Chercher les clips du dernier jour
        already_published_clip_ids=today_published_ids # Passer l'historique des clips publi√©s CE JOUR
    )

    if not eligible_clips_list:
        print("ü§∑‚Äç‚ôÇÔ∏è Aucun nouveau clip adapt√© trouv√© pour la publication aujourd'hui. Fin du script.")
        # Sortie normale si aucun clip √† traiter
        return 

    # --- Boucle de traitement et d'upload pour le nombre de clips souhait√© ---
    clips_published_count = 0
    for selected_clip in eligible_clips_list:
        if clips_published_count >= NUMBER_OF_CLIPS_TO_ATTEMPT_TO_PUBLISH:
            print(f"‚úÖ Objectif de {NUMBER_OF_CLIPS_TO_ATTEMPT_TO_PUBLISH} clip(s) atteint pour cette ex√©cution.")
            break # Sortir de la boucle si on a publi√© le nombre d√©sir√©

        # V√©rifier si ce clip a d√©j√† √©t√© tent√© OU PUBLI√â (par une ex√©cution pr√©c√©dente) dans cette journ√©e
        if selected_clip['id'] in clips_attempted_in_this_run or selected_clip['id'] in today_published_ids:
            print(f"‚ÑπÔ∏è Clip '{selected_clip['id']}' d√©j√† tent√© dans cette ex√©cution ou d√©j√† publi√© aujourd'hui. Passage au suivant.")
            continue # Passe au prochain clip √©ligible

        # Marquer le clip comme tent√© pour cette ex√©cution pour √©viter les re-tentatives imm√©diates
        clips_attempted_in_this_run.append(selected_clip['id'])
        print(f"\n‚ú® Tentative de publication du clip : '{selected_clip['title']}' par '{selected_clip['broadcaster_name']}' (ID: {selected_clip['id']})...")

        # 4. T√©l√©charger le clip
        downloaded_file = download_clip.download_twitch_clip(selected_clip['url'], RAW_CLIP_PATH)
        if not downloaded_file:
            print(f"‚ùå √âchec du t√©l√©chargement du clip '{selected_clip['id']}'. Passage au suivant.")
            # Nettoyage sp√©cifique si le t√©l√©chargement a laiss√© des traces
            if os.path.exists(RAW_CLIP_PATH): os.remove(RAW_CLIP_PATH)
            continue # Passe au prochain clip √©ligible

        # 5. Traiter/couper la vid√©o
        print("üé¨ Traitement de la vid√©o pour le format Short (d√©coupage si n√©cessaire)...")
        current_processed_file = PROCESSED_CLIP_PATH # Assurez-vous d'√©craser le pr√©c√©dent pour l'artefact final

        processed_file_path_returned = process_video.trim_video_for_short(
            input_path=downloaded_file,
            output_path=current_processed_file,
            max_duration_seconds=get_top_clips.MAX_VIDEO_DURATION_SECONDS,
            clip_data=selected_clip,
            enable_webcam_crop=False
        )
        
        # V√©rifications apr√®s traitement
        if not processed_file_path_returned or not os.path.exists(processed_file_path_returned) or os.path.getsize(processed_file_path_returned) == 0:
            print(f"‚ùå √âchec du traitement vid√©o pour le clip '{selected_clip['id']}'. Le fichier trait√© est manquant ou vide.")
            print("Tentative d'utiliser le fichier brut pour l'upload si possible (peut √™tre trop long).")
            final_video_for_upload = downloaded_file # Utilise le fichier brut comme fallback
            if not os.path.exists(final_video_for_upload) or os.path.getsize(final_video_for_upload) == 0:
                print(f"‚ùå Le fichier brut pour le clip '{selected_clip['id']}' est aussi vide ou introuvable. Impossible de continuer pour ce clip.")
                # Nettoyage des temporaires avant de passer au suivant
                if os.path.exists(RAW_CLIP_PATH): os.remove(RAW_CLIP_PATH)
                if os.path.exists(current_processed_file): os.remove(current_processed_file) 
                continue # Passe au prochain clip √©ligible
            else:
                print(f"Utilisation du fichier brut pour l'upload du clip '{selected_clip['id']}'.")
        else:
            print(f"‚úÖ Fichier trait√© trouv√© et non vide : {processed_file_path_returned} (taille : {os.path.getsize(processed_file_path_returned)} octets).")
            final_video_for_upload = processed_file_path_returned # Utilise le fichier trait√©

        # 6. G√©n√©rer les m√©tadonn√©es YouTube
        youtube_metadata = generate_metadata.generate_youtube_metadata(selected_clip)
        print("\n--- Informations sur le Short (pour d√©bogage) ---")
        print(f"Titre: {youtube_metadata.get('title')}")
        print(f"Description: {youtube_metadata.get('description')}")
        print(f"Tags: {', '.join(youtube_metadata.get('tags', []))}")
        print(f"Chemin de la vid√©o finale pour upload: {final_video_for_upload}")
        print("-------------------------------------------------\n")

        # 7. Authentifier et Uploader sur YouTube
        youtube_service = None
        try:
            youtube_service = upload_youtube.get_authenticated_service()
        except Exception as e:
            print(f"‚ùå Erreur lors de l'authentification YouTube : {e}")
            print("‚ÑπÔ∏è L'upload YouTube pour ce clip sera ignor√©. Le script continuera pour le prochain clip/l'artefact.")

        youtube_video_id = None
        if youtube_service:
            print("üì§ D√©marrage de l'upload YouTube...")
            try:
                youtube_video_id = upload_youtube.upload_youtube_short(youtube_service, final_video_for_upload, youtube_metadata)
                
                if youtube_video_id:
                    print(f"üéâ Short YouTube publi√© avec succ√®s ! ID: {youtube_video_id}")
                    # 8. Mettre √† jour l'historique des publications seulement si l'upload YouTube r√©ussit
                    try:
                        add_to_history(history, selected_clip['id'], youtube_video_id)
                        save_published_history(history)
                        # Recharger today_published_ids pour que la prochaine it√©ration de la boucle
                        # ou une ex√©cution future dans la m√™me journ√©e la voie comme publi√©e.
                        today_published_ids = get_today_published_ids(history) 
                        print(f"‚úÖ Clip '{selected_clip['id']}' ajout√© √† l'historique des publications.")
                        clips_published_count += 1 # Incr√©mente le compteur seulement si upload r√©ussi
                    except Exception as e:
                        print(f"‚ùå Erreur lors de l'ajout/sauvegarde √† l'historique apr√®s un upload r√©el: {e}")
                else:
                    print("‚ùå L'upload YouTube a √©chou√© ou n'a pas retourn√© d'ID. Le Short n'a pas √©t√© publi√© sur YouTube.")
                    print("‚ÑπÔ∏è Le script continuera pour le prochain clip/l'artefact.")
            except Exception as e:
                print(f"‚ùå Une erreur inattendue est survenue pendant l'upload YouTube : {e}")
                print("‚ÑπÔ∏è Le script continuera pour le prochain clip/l'artefact.")
        else:
            print("‚ùå Service YouTube non authentifi√©. L'upload YouTube pour ce clip est ignor√©.")
            print("‚ÑπÔ∏è Le script continuera pour le prochain clip/l'artefact.")

        # 9. Nettoyage des fichiers temporaires (uniquement le brut)
        print("üßπ Nettoyage des fichiers temporaires pour ce clip...")
        if os.path.exists(RAW_CLIP_PATH):
            os.remove(RAW_CLIP_PATH)
            print(f"  - Supprim√©: {RAW_CLIP_PATH}")
        # Le PROCESSED_CLIP_PATH est laiss√© pour √™tre collect√© comme artefact par GitHub Actions.
        # Il sera √©cras√© lors de la prochaine it√©ration ou du prochain run.

    # R√©sum√© de l'ex√©cution
    if clips_published_count == 0 and NUMBER_OF_CLIPS_TO_ATTEMPT_TO_PUBLISH > 0:
        print("\nü§∑‚Äç‚ôÇÔ∏è Aucune vid√©o n'a pu √™tre publi√©e avec succ√®s lors de cette ex√©cution.")
    elif clips_published_count > 0:
        print(f"\nüéâ {clips_published_count} Short(s) publi√©(s) avec succ√®s lors de cette ex√©cution.")
    
    print("‚úÖ Workflow termin√©.")

if __name__ == "__main__":
    main()
    print("DEBUG: Le script main.py s'est termin√© sans erreur Python.")